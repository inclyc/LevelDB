# 为层次（Level）优化的时序数据库	


## 开发动机

一般时序数据库设计为重视临近时间的数据，而距离当前时刻越远的数据则认为越不重要。这一设计思路普遍存在与各种现有的时序数据库中。然而，这个项目认为分层次的，有间隔的数据才是有价值的。例如，每隔2天，每隔10天，这样的数据，更能看出测量值随着主键变化的规律。


## 基本设计思路


主要分为三个区域，分别为 `内存缓冲(mem)`，`内存索引(index)`，`块(block)` 。内存缓冲负责直接承担写入的数据，内存索引负责将每个主键建立的时间线整理，将聚合参量缓存。


### 内存缓冲区(mem)

<p align="center">
<img src="assets/mem.svg" alt="内存缓冲区"></img>
</p>


此区域设计如图所示，按照时间戳`Timestamp`的尾随`0`的数量，其包含多个双端队列，每个双端队列的元素是一个`HashMap<K, V>`，这在`src/mem/memory_buffer`中定义。这样设计的目的是，假设需要查询，以时间戳间隔`1024`的数据，只需要用的`10`层以上的数据，而不需要读取层次以下的。


### 内存索引区(index)

此区域整理每个主键的`聚合`数据。聚合(Aggregation)，主要包含求和，求平均，求中位数，求最大值，求最小值等操作，这个仓库主要实现求和操作。这个区域的设计使得每次查询任意前若干个相邻时间戳的聚合值，都有着$O(\log n)$级别的复杂度。

<p align="center">
<img src="assets/index.svg" alt="内存缓冲区"></img>
</p>

如图所示，规定时间戳的尾随0的数量，来确认他“管理”几个节点的聚合值，比如`100`时间戳，就管理着`4`个之后时间的时间戳。程序每次更新时间戳二进制去掉最后一个`1`的位置，直到达到缓冲区终点为止。这部分代码可以在`src/index/line.rs`中找到。